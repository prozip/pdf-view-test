<div id="pf5d" class="pf w0 h0" data-page-no="5d"><div class="pc pc5d w0 h0"><img class="bi x0 y0 w1 h1" alt="" src="bg5d.png"/><div class="t m0 xbf h14 y80 ff7 fs7 fcb sc0 ls6 ws0">69<span class="_ _82"></span><span class="ffa">Make it work, make it right, make it fast</span></div><div class="t m0 x83 h15 y40 ff4 fsb fc3 sc0 ls42 ws27b"> Refactoring has no clear “done” moment. Yo<span class="_ _e"></span><span class="ls71 ws2d4">u will find yourself iterating while you</span></div><div class="t m0 x35 h15 y41 ff4 fsb fc3 sc0 ls5e ws274">implement, as well as <span class="_ _e"></span>when you revisit the <span class="ls3d ws117">code to add new<span class="_ _e"></span> functionality. For one met-</span></div><div class="t m0 x35 h15 y42 ff4 fsb fc3 sc0 ls30 ws58c">ric about when you definitely <span class="ff3 ls1f ws0">should</span><span class="ls3d ws357"> refactor, Martin Fowler’s <span class="ff3 ls2c ws58d">rule of three</span><span class="ls34 ws58e"> says that</span></span></div><div class="t m0 x35 h15 y43 ff4 fsb fc3 sc0 ls20 wsc7">around the time you’ve im<span class="_ _e"></span>plemented a sim<span class="ls38 wsc9">ilar thing three times, you should refactor</span></div><div class="t m0 x35 h15 y44 ff4 fsb fc3 sc0 ls5e ws58f">your code to provide an abstraction for th<span class="ls51 ws229">at behavior. I like this premise because it</span></div><div class="t m0 x35 h15 y45 ff4 fsb fc3 sc0 ls38 ws1f4">suggests a balance around refactoring: don’<span class="ls31 ws58">t abstract something immediately, or even</span></div><div class="t m0 x35 h15 y46 ff4 fsb fc3 sc0 ls6f ws590">after you’ve duplicat<span class="_ _e"></span>ed it twice, because <span class="_ _e"></span>it<span class="lsaa ws0"> m<span class="_ _1d"></span>i<span class="_ _1d"></span>g<span class="_ _1d"></span>h<span class="_ _1d"></span>t<span class="_ _1d"></span> b<span class="_ _1d"></span>e<span class="_ _0"></span> p<span class="_ _1d"></span>r<span class="_ _1d"></span>e<span class="_ _1d"></span>m<span class="_ _1d"></span>a<span class="_ _1d"></span>t<span class="_ _0"></span>u<span class="_ _1d"></span>r<span class="_ _1d"></span>e<span class="_ _1d"></span>.<span class="_ _1d"></span> W<span class="_ _1d"></span>a<span class="_ _0"></span>i<span class="_ _1d"></span>t<span class="_ _1d"></span> t<span class="_ _1d"></span>o<span class="_ _1d"></span> s<span class="_ _1d"></span>e<span class="_ _0"></span>e<span class="_ _1d"></span> w<span class="_ _1d"></span>h<span class="_ _1d"></span>a<span class="_ _1d"></span>t<span class="_ _1d"></span> u<span class="_ _0"></span>s<span class="_ _1d"></span>e</span></div><div class="t m0 x35 h15 y47 ff4 fsb fc3 sc0 ls34 ws3ae">cases arise. They will allow <span class="ls3a ws23f">you to generalize the solution m<span class="_ _e"></span>ore effectively and be sure</span></div><div class="t m0 x35 h15 y48 ff4 fsb fc3 sc0 ls34 ws9f">that it’s necessary.</div><div class="t m0 x83 h15 y49 ff4 fsb fc3 sc0 ls38 ws591"> Another aspect to making something righ<span class="ls30 ws52c">t is to use the strengths of the language</span></div><div class="t m0 x35 h15 y4a ff4 fsb fc3 sc0 ls71 ws263">to your advantage. Take a look at the fo<span class="ls36 ws25d">llowing code, whic<span class="_ _0"></span>h determines the most fre-</span></div><div class="t m0 x35 h15 y4b ff4 fsb fc3 sc0 ls72 ws592">quent intege<span class="_ _e"></span>r in a list:</div><div class="t m0 x35 h3b y983 ffd fs18 fc3 sc0 lsb2 ws0">def<span class="_"> </span>get_number_with_highest_count(counts):</div><div class="t m0 x87 h3b y36c ffd fs18 fc3 sc0 lsb2 ws0">max_count<span class="_"> </span>=<span class="_"> </span>0</div><div class="t m0 x87 h3b y984 ffd fs18 fc3 sc0 lsb2 ws0">for<span class="_"> </span>number,<span class="_"> </span>count<span class="_"> </span>in<span class="_"> </span>counts.items():</div><div class="t m0 x36 h3b y36d ffd fs18 fc3 sc0 lsb2 ws0">if<span class="_"> </span>count<span class="_"> </span>&gt;<span class="_"> </span>max_count:</div><div class="t m0 xe6 h3b y36e ffd fs18 fc3 sc0 lsb2 ws0">max_count<span class="_"> </span>=<span class="_"> </span>count</div><div class="t m0 xe6 h3b y36f ffd fs18 fc3 sc0 lsb2 ws0">number_with_highest_count<span class="_"> </span>=<span class="_"> </span>number</div><div class="t m0 x87 h3b y370 ffd fs18 fc3 sc0 lsb2 ws0">return<span class="_"> </span>number_with_highest_count</div><div class="t m0 x35 h3b y372 ffd fs18 fc3 sc0 lsb2 ws0">def<span class="_"> </span>most_frequent(numbers):</div><div class="t m0 x87 h3b y985 ffd fs18 fc3 sc0 lsb2 ws0">counts<span class="_"> </span>=<span class="_"> </span>{}</div><div class="t m0 x87 h3b y733 ffd fs18 fc3 sc0 lsb2 ws0">for<span class="_"> </span>number<span class="_"> </span>in<span class="_"> </span>numbers:</div><div class="t m0 xe2 h3b y986 ffd fs18 fc3 sc0 lsb2 ws0">counts:<span class="_ _74"></span>in<span class="_ _83"></span>if<span class="_"> </span>number</div><div class="t m0 xc h3b y71f ffd fs18 fc3 sc0 lsb2 ws0">1<span class="_ _46"></span>+=<span class="_ _84"></span>counts[number]</div><div class="t m0 x36 h3b y987 ffd fs18 fc3 sc0 lsb2 ws0">else:</div><div class="t m0 x2a h3b y735 ffd fs18 fc3 sc0 lsb2 ws0">1<span class="_ _85"></span>=<span class="_ _6d"></span>counts[number]</div><div class="t m0 x87 h3b y404 ffd fs18 fc1 sc0 lsb2 ws0">return<span class="_"> </span>get_number_with_highest_count(counts)</div><div class="t m0 x35 h15 y292 ff4 fsb fc3 sc0 ls34 ws143">I’ve made this <span class="ff3 lsae ws0">work</span><span class="ls1c ws165">, but Python has a few t<span class="_ _e"></span>ools for making this easier. The first tool</span></div><div class="t m0 x35 h15 y988 ff4 fsb fc3 sc0 ls42 ws206">helps with the code that increments the count. For each number in the list, it has to</div><div class="t m0 x35 h15 y294 ff4 fsb fc3 sc0 ls44 ws593">check if we’ve already seen it to know if it<span class="ls30 ws52c"> can increment the count or if it <span class="_ _e"></span>has to ini-</span></div><div class="t m0 x35 h15 y989 ff4 fsb fc3 sc0 ls71 wsee">tialize the count. Python has a built-in da<span class="ls5e ws594">ta type to avoid this extra leg work: the</span></div><div class="t m5 x35 h24 y98a ffd fsc fc3 sc0 lsa0 ws0">defaultdict</div><div class="t m0 xe6 h15 y98b ff4 fsb fc3 sc0 ls20 ws2f8">. You can tell a </div><div class="t m5 x93 h24 y98a ffd fsc fc3 sc0 lsa0 ws0">defaultdict</div><div class="t m0 x2b h15 y98b ff4 fsb fc3 sc0 ls7d ws3b1"> the type of the values it stores, and it will</div><div class="t m0 x35 h15 y296 ff4 fsb fc3 sc0 ls2d ws31">default to a sensible value of that type if a new key is accessed:</div><div class="t m0 x35 h3b y98c ffd fs18 fc3 sc0 lsb2 ws0">from<span class="_"> </span>collections<span class="_"> </span>import<span class="_"> </span>defaultdict</div><div class="t m0 x35 h3b y98d ffd fs18 fc3 sc0 lsb2 ws0">def<span class="_"> </span>get_number_with_highest_count(counts):</div><div class="t m0 x87 h3b y98e ffd fs18 fc3 sc0 lsb2 ws0">max_count<span class="_"> </span>=<span class="_"> </span>0</div><div class="t m0 x87 h3b y98f ffd fs18 fc3 sc0 lsb2 ws0">for<span class="_"> </span>number,<span class="_"> </span>count<span class="_"> </span>in<span class="_"> </span>counts.items():</div><div class="t m0 x36 h3b y990 ffd fs18 fc3 sc0 lsb2 ws0">if<span class="_"> </span>count<span class="_"> </span>&gt;<span class="_"> </span>max_count:</div><div class="t m0 xe6 h3b y991 ffd fs18 fc3 sc0 lsb2 ws0">max_count<span class="_"> </span>=<span class="_"> </span>count</div><div class="t m0 xe6 h3b y992 ffd fs18 fc3 sc0 lsb2 ws0">number_with_highest_count<span class="_"> </span>=<span class="_"> </span>number</div><div class="t m0 x87 h3b y993 ffd fs18 fc3 sc0 lsb2 ws0">return<span class="_"> </span>number_with_highest_count</div><div class="c x113 y994 w2c h9e"><div class="t m0 xc8 h14 y995 ff12 fs7 fcb sc0 lsde ws0">Dete<span class="ff13 ls123">rm</span><span class="ls6">i<span class="ff13">n</span><span class="ls117 ws595">es th<span class="_ _e"></span>e </span><span class="ff13">n</span>u<span class="ff13">m</span><span class="lsec">be</span><span class="ff13">r</span><span class="lse0 ws596"> with the </span></span></div><div class="t m0 xc8 h14 y996 ff12 fs7 fcb sc0 ls102 ws597">highest cou<span class="ff13 ls6 ws0">n</span><span class="lsd2 ws598">t i<span class="ff13 ls6 ws0">n</span><span class="ls106 ws599"> a dict that <span class="ff13 ls6 ws0">m<span class="ff12 ls17f">aps </span></span></span></span></div><div class="t m0 xc8 h14 y997 ff13 fs7 fcb sc0 ls6 ws0">n<span class="ff12">u</span>m<span class="ff12 lsec">be</span>r<span class="ff12 ls102 ws3cd">s to cou</span>n<span class="ff12 lsd2">ts</span></div></div><div class="c x6b y998 w2c h9f"><div class="t m0 xc8 h14 y999 ff12 fs7 fcb sc0 lsd6 ws59a">Tallies up the occu<span class="ff13 ls123 ws0">rr<span class="ff12 ls6">e<span class="ff13">n</span><span class="ws59b">ce of </span></span></span></div><div class="t m0 xc8 h14 y99a ff13 fs7 fcb sc0 ls6 ws0">n<span class="ff12">u</span>m<span class="ff12 lsec">be</span>r<span class="ff12 ls106 ws45d">s to see which has </span></div><div class="t m0 xc8 h14 y99b ff12 fs7 fcb sc0 lsfd ws31a">the highest cou<span class="ff13 ls6 ws0">n<span class="ff12">t</span></span></div></div><div class="c x10e y99c w2c h43"><div class="t m0 xc8 h14 y2f5 ff12 fs7 fcb sc0 ls6 ws0">I<span class="ff13">m</span><span class="lsec">po</span><span class="ff13">r</span><span class="lsd6 ws59c">ts defaultdict f</span><span class="ff13">r</span>o<span class="ff13">m</span> </div><div class="t m0 xc8 h14 y2f7 ff12 fs7 fcb sc0 ls88 ws2d0">the collectio<span class="ff13 ls6 ws0">n<span class="ff12 ls10e">s </span>m<span class="ff12 lsde">odule</span></span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
